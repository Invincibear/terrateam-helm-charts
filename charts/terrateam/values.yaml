# These will be applied to all deployed resources, unless overriden
# For example, server.labels will override global.labels
global:
  annotations: {}
  labels: {}

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}
  imagePullSecrets: []


server:
  name: terrateam-server
  replicaCount: 1
  dns_name: &server_dns_name "terrateam.my-domain.tld"
  db_host: terrateam-db
  db_port: 5432
  db_user: terrateam
  db_name: terrateam
  github_webhook_url_update: "true"
  self_hosted_infracost_api_key: ""
  infracost_pricing_api_endpoint: ""
  telemetry_level: "anonymous"
  image:
    repository: ghcr.io/terrateamio/terrat-oss
    tag: "latest"
    pullPolicy: Always
  imagePullSecrets: []
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi
  annotations: {}
  labels: {}
  nodeSelector: {}
  tolerations: []


# For convenience and testing, we include a PostgreSQL database deployment to store Terrateam data.
# You might want to consider a more robust solution hosted by a cloud provider or
# a dedicated PostgreSQL deployment with HA
db:
  # Set to false to use an external PostgreSQL server
  enabled: true

  # The name of the PostgreSQL server pod
  name: terrateam-db

  # db.annotations & db.labels will be merged with global.annotations & global.labels,
  # and will override global.annotations & global.labels if conflicting
  annotations: {}
  labels: {}

  # These affect the environment variables injected into the PostgreSQL server pod
  config:
    # PostgreSQL uses port 5432 by default
    port: 5432

    # The name of the database to create inside the PostgreSQL server.
    # Remember to update server.db.databaseName with this value
    databaseName: terrateam

    # The name of the admin user to create.
    # Remember to update server.db.username with this value
    username: terrateam

    # The password of the admin user to create is derived from a Kubernetes secret.
    # You can manually create the secret with kubectl, or Terraform it with resource.kubernetes_secret_v1,
    # Or use external-secrets to pull the value from a Vault
    passwordSecretName: terrateam-db-password
    passwordSecretKey: password

  image:
    repository: postgres
    tag: "14.18-alpine"
    pullPolicy: IfNotPresent
  imagePullSecrets: []

  # You may want to tune these depending on how many concurrent runs Terrateam serves
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi

  # Persistent DB storage settings
  pvc:
    name: terrateam-db-data-claim

    # db.pvc.annotations will be merged with global.annotations & global.db.annotations,
    # and will override global.annotations & global.db.annotations if conflicting
    annotations: {}

    # db.pvc.labels will be merged with global.labels & global.db.labels,
    # and will override global.labels & global.db.labels if conflicting
    labels: {}

    # The size of the PV requested by the PVC to ensure data persistence
    storageSize: 1Gi

    # The name of the StorageClass that provides the PersistentVolume.
    # Most Kubernetes clusters have a "default" StorageClass that is used when unspecified
    storageClassName: ""

  service:
    # The name of the Service created for the PostgreSQL server.
    # Defaults to db.name if unspecified
    name: ""

    # db.service.annotations will be merged with global.annotations & global.db.annotations,
    # and will override global.annotations & global.db.annotations if conflicting
    annotations: {}

    # db.service.labels will be merged with global.labels & global.db.labels,
    # and will override global.labels & global.db.labels if conflicting
    labels: {}

    # ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # The port the service will expose
    # Defaults to db.config.port if undefined
    port: ""

    # NodePort should only be defined if db.service.type = NodePort
    # If undefined, Kubernetes will pick a random port in the 30000-32767 range
    nodePort: ""

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}


ingress:
  enabled: false
  name: &ingress_name "terrateam-ingress"
  className: ""

  annotations: {}
  labels: {}

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}


# Optionally generate a certificate for your ingress
certificate:
  enabled: false

  # Defaults to "{ingress.name}-certificate" if unspecified
  name: ""

  # certificate.annotations & certificate.labels will be merged with global.annotations & global.labels,
  # and will override global.annotations & global.labels if conflicting
  annotations: {}
  labels: {}

  apiVersion: ""
  kind: ""

  # The complete spec section for the cert, allows full flexibility for any cert provider
  spec: {}

  # GKE example
  # apiVersion: networking.gke.io/v1
  # kind: ManagedCertificate
  # spec:
  #   domains:
  #     - *server_dns_name

  # cert-manager example
  # apiVersion: cert-manager.io/v1
  # kind: Certificate
  # spec:
  #   secretName: terrateam-tls # Remember to update ingress.tlsSecretName with this value
  #   dnsNames:
  #     - terrateam.example.com
  #   issuerRef:
  #     name: letsencrypt-prod
  #     kind: ClusterIssuer
