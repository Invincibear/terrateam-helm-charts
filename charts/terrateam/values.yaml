##
## These will be applied to all deployed resources, unless overriden
## For example, terrateam.labels will override global.labels
##
global:
  annotations: {}
  labels: {}

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}
  imagePullSecrets: []


##
## Terrateam
##
terrateam:
  name: terrateam-server

  # terrateam.annotations & terrateam.labels will be merged with global.annotations & global.labels,
  # and will override global.annotations & global.labels if conflicting
  annotations: {}
  labels: {}

  image:
    repository: ghcr.io/terrateamio/terrat-oss

    # For production use it is recommended that you pin a specific tag
    tag: "latest"

    # Use "Always" if terrateam.image.tag = latest to bust the Kubernetes image cache
    pullPolicy: Always
  imagePullSecrets: []

  config:
    db:
      # If db.enabled = true, otherwise my-psql-hostname.my-domain.tld
      hostname: terrateam-db

      # PostgreSQL uses port 5432 by default
      port: 5432
      username: terrateam
      databaseName: terrateam

      # The password of the admin user to create is derived from a Kubernetes secret.
      # You can manually create the secret with kubectl, or Terraform it with resource.kubernetes_secret_v1,
      # Or use external-secrets to pull the value from a Vault
      passwordSecretName: terrateam-db-password
      passwordSecretKey: password

    # Optionally pass extra environment variables into the PostgreSQL server container
    extraEnv: {}
  dns_name: &server_dns_name "terrateam.my-domain.tld"
  github_webhook_url_update: "true"
  self_hosted_infracost_api_key: ""
  infracost_pricing_api_endpoint: ""
  telemetry_level: "anonymous"

  github:
    appIdSecretName: terrateam-github-app-id
    appIdSecretKey: id
    appClientIdSecretName: terrateam-github-app-client-id
    appClientIdSecretKey: id
    appClientSecretSecretName: terrateam-github-app-client-secret
    appClientSecretSecretKey: secret
    appPrivatePEMCertificateSecretName: terrateam-github-app-pem
    appPrivatePEMCertificateSecretKey: pem
    webhookSecretName: terrateam-github-webhook-secret
    webhookSecretKey: secret


  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi

  # Terrateam horizontally scales, you are effectively limited by your DB's available resources
  replicaCount: 1

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}

  service:
    # The name of the Service created for Terrateam.
    # Defaults to terrateam.name if unspecified
    name: ""

    # terrateam.service.annotations will be merged with global.annotations & global.terrateam.annotations,
    # and will override global.annotations & global.terrateam.annotations if conflicting
    annotations: {}

    # terrateam.service.labels will be merged with global.labels & global.terrateam.labels,
    # and will override global.labels & global.terrateam.labels if conflicting
    labels: {}

    # ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # The port the service will expose
    port: 8080

    # NodePort should only be defined if db.service.type = NodePort
    # If undefined, Kubernetes will pick a random port in the 30000-32767 range
    nodePort: ""


##
## Optionally create an Nginx ingress
##
ingress:
  enabled: false
  name: &ingress_name "terrateam-ingress"

  className: "nginx"
  tlsSecretName: "terrateam-tls"

  annotations: {}
  labels: {}

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}

  # Optionally generate a TLS certificate for your ingress
  certificate:
    enabled: false

    # Defaults to "{ingress.name}-certificate" if unspecified
    name: ""

    # certificate.annotations & certificate.labels will be merged with global.annotations & global.labels,
    # and will override global.annotations & global.labels if conflicting
    annotations: {}
    labels: {}

    apiVersion: ""
    kind: ""

    # The complete spec section for the cert, allows full flexibility for any cert provider
    spec: {}

    # GKE example
    # apiVersion: networking.gke.io/v1
    # kind: ManagedCertificate
    # spec:
    #   domains:
    #     - *server_dns_name

    # cert-manager example
    # apiVersion: cert-manager.io/v1
    # kind: Certificate
    # spec:
    #   secretName: terrateam-tls # Remember to update ingress.tlsSecretName with this value
    #   dnsNames:
    #     - *server_dns_name
    #   issuerRef:
    #     name: letsencrypt-prod
    #     kind: ClusterIssuer


##
## For convenience and testing, we include a PostgreSQL database deployment to store Terrateam data.
## You might want to consider a more robust solution hosted by a cloud provider or
## a dedicated PostgreSQL deployment with HA
##
db:
  # Set to false to use an external PostgreSQL server
  enabled: true

  # The name of the PostgreSQL server pod
  name: terrateam-db

  # db.annotations & db.labels will be merged with global.annotations & global.labels,
  # and will override global.annotations & global.labels if conflicting
  annotations: {}
  labels: {}

  # These affect the environment variables injected into the PostgreSQL server container
  config:
    # PostgreSQL uses port 5432 by default
    port: 5432

    # The name of the database to create inside the PostgreSQL server.
    # Remember to update terrateam.db.databaseName with this value
    databaseName: terrateam

    # The name of the admin user to create.
    # Remember to update terrateam.db.username with this value
    username: terrateam

    # The password of the admin user to create is derived from a Kubernetes secret.
    # You can manually create the secret with kubectl, or Terraform it with resource.kubernetes_secret_v1,
    # Or use external-secrets to pull the value from a Vault
    passwordSecretName: terrateam-db-password
    passwordSecretKey: password

    # Optionally pass extra environment variables into the PostgreSQL server container
    extraEnv: {}

  image:
    repository: postgres
    tag: "14.18-alpine"
    pullPolicy: IfNotPresent
  imagePullSecrets: []

  # You may want to tune these depending on how many concurrent runs Terrateam serves
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi

  nodeSelector: {}
  tolerations: []

  affinity: {}
  securityContext: {}

  # Persistent DB storage settings
  pvc:
    name: terrateam-db-data-claim

    # db.pvc.annotations will be merged with global.annotations & global.db.annotations,
    # and will override global.annotations & global.db.annotations if conflicting
    annotations: {}

    # db.pvc.labels will be merged with global.labels & global.db.labels,
    # and will override global.labels & global.db.labels if conflicting
    labels: {}

    # The size of the PV requested by the PVC to ensure data persistence
    storageSize: 1Gi

    # The name of the StorageClass that provides the PersistentVolume.
    # Most Kubernetes clusters have a "default" StorageClass that is used when unspecified
    storageClassName: ""

  service:
    # The name of the Service created for the PostgreSQL server.
    # Defaults to db.name if unspecified
    name: ""

    # db.service.annotations will be merged with global.annotations & global.db.annotations,
    # and will override global.annotations & global.db.annotations if conflicting
    annotations: {}

    # db.service.labels will be merged with global.labels & global.db.labels,
    # and will override global.labels & global.db.labels if conflicting
    labels: {}

    # ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # The port the service will expose
    # Defaults to db.config.port if undefined
    port: ""

    # NodePort should only be defined if db.service.type = NodePort
    # If undefined, Kubernetes will pick a random port in the 30000-32767 range
    nodePort: ""
